// This file was automatically generated by ../script/extract.js
import * as t from "io-ts";

export const FunctionKind = t.union([
	t.tuple([t.literal("Function")]),
	t.tuple([t.literal("Macro")]),
	t.tuple([t.literal("Constructor")]),
	t.tuple([t.literal("RecordField")]),
	t.tuple([t.literal("ClassMember")]),
	t.tuple([t.literal("ClassMacro")])
])

export const ABCArgumentType = t.union([
	t.tuple([t.literal("ABCTypeLabel")]),
	t.tuple([t.literal("ABCTypeAStackOffset")]),
	t.tuple([t.literal("ABCTypeBStackOffset")]),
	t.tuple([t.literal("ABCTypeAStackSize")]),
	t.tuple([t.literal("ABCTypeBStackSize")]),
	t.tuple([t.literal("ABCTypeBool")]),
	t.tuple([t.literal("ABCTypeChar")]),
	t.tuple([t.literal("ABCTypeInt")]),
	t.tuple([t.literal("ABCTypeReal")]),
	t.tuple([t.literal("ABCTypeString")])
])

export const LocationResult = t.tuple([t.string,t.string,t.string,t.union([
	t.tuple([t.literal("Just"),t.number]),
	t.tuple([t.literal("Nothing")])
]),t.union([
	t.tuple([t.literal("Just"),t.number]),
	t.tuple([t.literal("Nothing")])
])]); // ** * A type unifier, represented with strings. *

export const Request = t.partial({
	unify: t.string,
	name: t.string,
	exactName: t.string,
	className: t.string,
	typeName: t.string,
	using: t.array(t.string),
	modules: t.array(t.string),
	libraries: t.array(t.string),
	include_builtins: t.boolean,
	include_core: t.boolean,
	include_apps: t.boolean,
	page: t.number,
});

export const CleanLangReportLocation = t.type({
	clr_version: t.string,
	clr_section: t.string,
});

export const TypeResultExtras_opt = t.partial({
	type_field_doc: t.array(t.union([
	t.tuple([t.literal("Just"),t.string]),
	t.tuple([t.literal("Nothing")])
])),
	type_constructor_doc: t.array(t.union([
	t.tuple([t.literal("Just"),t.string]),
	t.tuple([t.literal("Nothing")])
])),
	type_representation_doc: t.string,
});

export const TypeResultExtras_req = t.type({
	type: t.string,
	type_instances: t.array(t.tuple([t.string,t.array(t.string),t.array(LocationResult)])),
	type_derivations: t.array(t.tuple([t.string,t.array(LocationResult)])),
});

export const TypeResultExtras = t.intersection([TypeResultExtras_req, TypeResultExtras_opt]);

export const ClassResultExtras_opt = t.partial({
	class_fun_doc: t.array(t.union([
	t.tuple([t.literal("Just"),t.string]),
	t.tuple([t.literal("Nothing")])
])),
});

export const ClassResultExtras_req = t.type({
	class_name: t.string,
	class_heading: t.string,
	class_funs: t.array(t.string),
	class_instances: t.array(t.tuple([t.array(t.string),t.array(LocationResult)])),
});

export const ClassResultExtras = t.intersection([ClassResultExtras_req, ClassResultExtras_opt]);

export const ModuleResultExtras = t.type({
	module_is_core: t.boolean,
});

export const SyntaxExample_opt = t.partial({
	cleanjs_start: t.string,
});

export const SyntaxExample_req = t.type({
	example: t.string,
	bootstrap: t.array(t.string),
	requires_itask_compiler: t.boolean,
});

export const SyntaxExample = t.intersection([SyntaxExample_req, SyntaxExample_opt]);

export const ProblemResult = t.type({
	problem_key: t.string,
	problem_title: t.string,
	problem_description: t.string,
	problem_solutions: t.array(t.string),
	problem_examples: t.array(t.string),
});

export const StrUnifier = t.type({
	left_to_right: t.array(t.tuple([t.string,t.string])),
	right_to_left: t.array(t.tuple([t.string,t.string])),
	used_synonyms: t.array(t.tuple([t.string,t.string])),
});

export const ShortClassResult = t.type({
	cls_name: t.string,
	cls_vars: t.array(t.string),
});

export const ABCArgument = t.tuple([t.literal("ABCArgument"),ABCArgumentType,t.boolean])

export const BasicResult_opt = t.partial({
	dcl_line: t.number,
	icl_line: t.number,
	distance: t.number,
	builtin: t.boolean,
	documentation: t.string,
	langrep_documentation: t.array(CleanLangReportLocation),
});

export const BasicResult_req = t.type({
	library: t.string,
	filename: t.string,
	modul: t.string,
	name: t.string,
});

export const BasicResult = t.intersection([BasicResult_req, BasicResult_opt]);

export const FunctionResultExtras_opt = t.partial({
	unifier: StrUnifier,
	required_context: t.array(t.tuple([t.string,t.array(LocationResult)])),
	cls: ShortClassResult,
	constructor_of: t.string,
	recordfield_of: t.string,
	generic_derivations: t.array(t.tuple([t.string,t.array(LocationResult)])),
	param_doc: t.array(t.string),
	generic_var_doc: t.array(t.string),
	result_doc: t.array(t.string),
	type_doc: t.string,
	throws_doc: t.array(t.string),
});

export const FunctionResultExtras_req = t.type({
	func: t.string,
	kind: FunctionKind,
});

export const FunctionResultExtras = t.intersection([FunctionResultExtras_req, FunctionResultExtras_opt]);

export const SyntaxResultExtras = t.type({
	syntax_title: t.string,
	syntax_code: t.array(t.string),
	syntax_examples: t.array(SyntaxExample),
});

export const ABCInstructionResultExtras = t.type({
	abc_instruction: t.string,
	abc_arguments: t.array(ABCArgument),
});

export const FunctionResult = t.tuple([BasicResult,FunctionResultExtras]); // ** * Different kinds of Clean functions. *

export const TypeResult = t.tuple([BasicResult,TypeResultExtras]); // ** * Type-specific Cloogle result data. *

export const ClassResult = t.tuple([BasicResult,ClassResultExtras]); // ** * Class-specific Cloogle result data. *

export const ModuleResult = t.tuple([BasicResult,ModuleResultExtras]); // ** * Module-specific Cloogle result data. *

export const SyntaxResult = t.tuple([BasicResult,SyntaxResultExtras]); // ** * Syntax contruct-specific Cloogle result data. *

export const ABCInstructionResult = t.tuple([BasicResult,ABCInstructionResultExtras]); // ** * Information about an ABC instruction. *

export const Result = t.union([
	t.tuple([t.literal("FunctionResult"),FunctionResult]),
	t.tuple([t.literal("TypeResult"),TypeResult]),
	t.tuple([t.literal("ClassResult"),ClassResult]),
	t.tuple([t.literal("ModuleResult"),ModuleResult]),
	t.tuple([t.literal("SyntaxResult"),SyntaxResult]),
	t.tuple([t.literal("ABCInstructionResult"),ABCInstructionResult]),
	t.tuple([t.literal("ProblemResult"),ProblemResult])
])

export const Response_opt = t.partial({
	more_available: t.number,
	suggestions: t.array(t.tuple([Request,t.number])),
	warnings: t.array(t.string),
});

export const Response_req = t.type({
	data: t.array(Result),
	msg: t.string,
});

export const Response = t.intersection([Response_req, Response_opt]);
